#!/usr/bin/env bash
#
# accept.sh - Convert tasks.md to tasks.jsonc for Spectr changes
#
# Usage: accept.sh <change-id>
#
# This script reads spectr/changes/<id>/tasks.md and generates
# spectr/changes/<id>/tasks.jsonc in the format expected by Spectr.
#
# Requirements: jq (for JSON generation)
#

set -euo pipefail

# Check if change-id argument is provided
if [ $# -ne 1 ]; then
    echo "Usage: $0 <change-id>" >&2
    echo "Example: $0 add-new-feature" >&2
    exit 1
fi

CHANGE_ID="$1"
TASKS_MD="spectr/changes/${CHANGE_ID}/tasks.md"
TASKS_JSONC="spectr/changes/${CHANGE_ID}/tasks.jsonc"

# Verify tasks.md exists
if [ ! -f "$TASKS_MD" ]; then
    echo "Error: $TASKS_MD does not exist" >&2
    exit 1
fi

# Check if jq is available
if ! command -v jq >/dev/null 2>&1; then
    echo "Error: jq is required but not installed" >&2
    echo "Install jq: https://jqlang.github.io/jq/download/" >&2
    exit 1
fi

# Generate JSONC header with comprehensive comments
JSONC_HEADER='// Spectr Tasks File (JSONC)
//
// This file contains machine-readable task definitions for a Spectr change.
// JSONC format allows comments while maintaining JSON compatibility.
//
// Status Values:
//   - "pending"     : Task has not been started yet
//   - "in_progress" : Task is currently being worked on
//   - "completed"   : Task has been finished and verified
//
// Status Transitions:
//   pending -> in_progress -> completed
//
//   Tasks should only move forward through these states.
//   Do not skip states or move backward.
//
// Workflow:
//   1. BEFORE starting work on a task, mark it as "in_progress"
//   2. Complete the implementation for the task
//   3. Verify the work is correct and complete
//   4. IMMEDIATELY mark the task as "completed" after verification
//   5. Move to the next task and repeat
//
// IMPORTANT - Update Status Immediately:
//   - Update each task'\''s status IMMEDIATELY after it transitions
//   - Do NOT batch status updates at the end of all work
//   - Do NOT wait until all tasks are done to update statuses
//   - This file should reflect accurate progress at any point in time
//   - Using a single edit to mark a task completed AND the next task
//     in_progress is allowed (this is a single transition, not batching)
//
// Note: This file is auto-generated by '\''spectr accept'\''. Manual edits to
// task status are expected, but structure changes may be overwritten.
//
'

# Parse tasks.md and convert to JSON
# Task format: - [ ] 1.1 Task description OR - [x] 1.1 Task description
# Section formats supported:
#   Format 1: # Category, ## N. Section Name (use ## for sections)
#   Format 2: # N. Section Name, ## Tasks (use # for sections)

parse_tasks() {
    local current_section=""
    local h1_section=""
    local tasks_array="[]"

    while IFS= read -r line; do
        # Check for # level header (could be section in Format 2)
        if [[ "$line" =~ ^#[[:space:]](.+)$ ]]; then
            h1_section="${BASH_REMATCH[1]}"
            # Remove leading number prefix like "1. " if present
            h1_section=$(echo "$h1_section" | sed -E 's/^[0-9]+\.[[:space:]]*//')
            continue
        fi

        # Check for ## level header
        if [[ "$line" =~ ^##[[:space:]](.+)$ ]]; then
            local h2_text="${BASH_REMATCH[1]}"
            # Remove leading number prefix like "2. " if present
            h2_text=$(echo "$h2_text" | sed -E 's/^[0-9]+\.[[:space:]]*//')

            # If ## says "Tasks", use the # level as section (Format 2)
            # Otherwise use ## level as section (Format 1)
            if [[ "$h2_text" == "Tasks" ]]; then
                current_section="$h1_section"
            else
                current_section="$h2_text"
            fi
            continue
        fi

        # Check for task line: - [ ] or - [x] followed by ID and description
        if [[ "$line" =~ ^-[[:space:]]\[([[:space:]]|x)\][[:space:]]([0-9]+\.[0-9]+)[[:space:]](.+)$ ]]; then
            local checkbox="${BASH_REMATCH[1]}"
            local task_id="${BASH_REMATCH[2]}"
            local description="${BASH_REMATCH[3]}"

            # Determine status based on checkbox
            local status="pending"
            if [[ "$checkbox" == "x" ]]; then
                status="completed"
            fi

            # Escape description for JSON
            description=$(echo "$description" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')

            # Add task to array using jq
            tasks_array=$(echo "$tasks_array" | jq --arg id "$task_id" \
                                                    --arg section "$current_section" \
                                                    --arg desc "$description" \
                                                    --arg status "$status" \
                                                    '. + [{
                                                        "id": $id,
                                                        "section": $section,
                                                        "description": $desc,
                                                        "status": $status
                                                    }]')
        fi
    done < "$TASKS_MD"

    echo "$tasks_array"
}

# Parse tasks and generate JSON structure
TASKS_JSON=$(parse_tasks)

# Create final JSON structure
FINAL_JSON=$(jq -n --argjson tasks "$TASKS_JSON" '{
    "version": 1,
    "tasks": $tasks
}')

# Write JSONC file with header + formatted JSON
{
    echo "$JSONC_HEADER"
    echo "$FINAL_JSON"
} > "$TASKS_JSONC"

echo "Successfully generated $TASKS_JSONC from $TASKS_MD"
echo "Tasks parsed: $(echo "$TASKS_JSON" | jq 'length')"
