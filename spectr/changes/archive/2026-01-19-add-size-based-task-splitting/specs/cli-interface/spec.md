# Delta Spec: CLI Interface - Size-Based Task Splitting

## ADDED Requirements

### Requirement: Tasks JSON Schema

The system SHALL generate a versioned `tasks.jsonc` with optional hierarchical
structure for large task files, automatically splitting files over 100 lines
while preserving section boundaries.

#### Scenario: JSONC file structure

- **WHEN** generating tasks.jsonc
- **THEN** the file SHALL start with header comments documenting status values
  and transitions
- **AND** the file SHALL contain a root object with `version` and `tasks` fields
- **AND** `version` SHALL be integer 2 for hierarchical files, integer 1 for flat
  files
- **AND** `tasks` SHALL be an array of task objects

#### Scenario: Version 2 hierarchical structure

- **WHEN** tasks.md exceeds 100 lines during accept
- **THEN** the system SHALL generate version 2 tasks.jsonc with split files
- **AND** root file SHALL contain reference tasks with `children` field
- **AND** child files SHALL be named `tasks-N.jsonc` where N is sequential
- **AND** root file SHALL include `includes` field with glob pattern `["tasks-*.jsonc"]`

#### Scenario: Version 1 flat structure preserved

- **WHEN** tasks.md is 100 lines or fewer
- **THEN** the system SHALL generate version 1 tasks.jsonc with flat structure
- **AND** no split files SHALL be created

#### Scenario: Header comment content

- **WHEN** generating root tasks.jsonc
- **THEN** the header SHALL use `//` line comment syntax
- **AND** the header SHALL indicate the file is machine-generated by `spectr accept`
- **AND** the header SHALL document the three valid status values: "pending",
  "in_progress", "completed"
- **AND** the header SHALL document valid status transitions: pending -> in_progress
  -> completed
- **AND** the header SHALL explain that agents should mark a task "in_progress"
  when starting work
- **AND** the header SHALL explain that agents should mark a task "completed"
  only after verification
- **AND** the header SHALL note that skipping directly from "pending" to
  "completed" is allowed for trivial tasks

#### Scenario: Child file header content

- **WHEN** generating child tasks-N.jsonc files
- **THEN** the header SHALL include the full header from root file
- **AND** the header SHALL add "Generated by: spectr accept \<change-id\>"
- **AND** the header SHALL add "Parent change: \<change-id\>"
- **AND** the header SHALL add "Parent task: \<parent-task-id\>"

#### Scenario: Task object structure

- **WHEN** a task is serialized to JSONC
- **THEN** it SHALL have `id` field containing the task identifier (e.g., "1.1")
- **AND** it SHALL have `section` field containing the section header (e.g., "Implementation")
- **AND** it SHALL have `description` field containing the full task text
- **AND** it SHALL have `status` field with value "pending", "in_progress", or "completed"
- **AND** it MAY have `children` field with value "$ref:\<path\>" for reference tasks

#### Scenario: Status value mapping from Markdown

- **WHEN** converting tasks from markdown
- **THEN** map `- [ ]` to status "pending"
- **AND** map `- [x]` to status "completed"

#### Scenario: Reference task structure

- **WHEN** a task references child tasks in a split file
- **THEN** it SHALL have all standard fields (id, section, description, status)
- **AND** it SHALL have `children` field with value "$ref:tasks-N.jsonc"
- **AND** the description SHALL be the section header or summary
- **AND** the status SHALL reflect aggregate status of children (pending if any
  pending, in_progress if any in_progress, completed if all completed)

#### Scenario: Child file structure

- **WHEN** generating a child tasks-N.jsonc file
- **THEN** it SHALL have `version` field set to 2
- **AND** it SHALL have `parent` field containing the parent task ID
- **AND** it SHALL have `tasks` array with child task objects
- **AND** child task IDs SHALL use dot notation (e.g., "1.1", "1.2" for parent "1")

#### Scenario: Includes field for discovery

- **WHEN** generating version 2 root tasks.jsonc
- **THEN** it SHALL include `includes` field with value `["tasks-*.jsonc"]`
- **AND** agents MAY use this glob pattern to discover all split files

### Requirement: Automatic Task File Splitting

The system SHALL automatically split large tasks.md files during `spectr accept`
based on a 100-line threshold, using section boundaries for clean breaks.

#### Scenario: Detect large tasks.md file

- **WHEN** running `spectr accept <change-id>`
- **THEN** the system SHALL count lines in tasks.md
- **AND** if line count exceeds 100, enable splitting mode

#### Scenario: Split by section boundaries

- **WHEN** splitting is enabled
- **THEN** the system SHALL identify top-level sections (lines starting with
  `## N.`)
- **AND** each section SHALL be evaluated for splitting into its own file
- **AND** the root tasks.jsonc SHALL contain reference tasks for each split
  section

#### Scenario: Split large sections by subsections

- **WHEN** a single section exceeds 100 lines
- **THEN** the system SHALL identify subsections by task ID prefixes (e.g., "1.1",
  "1.2")
- **AND** group related tasks with common ID prefixes together
- **AND** split subsection groups into separate files if needed

#### Scenario: Preserve small sections in root

- **WHEN** splitting is enabled
- **THEN** sections with fewer than 10 tasks MAY remain in root file
- **AND** the system SHALL prioritize splitting largest sections first

#### Scenario: Sequential file naming

- **WHEN** generating split files
- **THEN** name files sequentially: tasks-1.jsonc, tasks-2.jsonc, etc.
- **AND** the sequence SHALL follow section order from tasks.md

#### Scenario: Regenerate from tasks.md

- **WHEN** running `spectr accept` on a change with existing tasks.jsonc
- **THEN** the system SHALL delete all existing tasks-*.jsonc files
- **AND** regenerate all files from tasks.md
- **AND** preserve status values from existing tasks.jsonc where task IDs match

### Requirement: Hierarchical Task ID Schema

The system SHALL support hierarchical task IDs using dot notation to represent
parent-child relationships.

#### Scenario: Root task IDs

- **WHEN** a task is in the root tasks.jsonc
- **THEN** its ID SHALL be a single integer or decimal (e.g., "1", "2", "5")

#### Scenario: Child task IDs

- **WHEN** a task is in a child file with parent ID "5"
- **THEN** its ID SHALL be prefixed with parent ID (e.g., "5.1", "5.2")

#### Scenario: Nested child task IDs

- **WHEN** a child task has its own children (subsections within a split section)
- **THEN** IDs SHALL use additional dot notation (e.g., "5.1.1", "5.1.2")

#### Scenario: ID uniqueness within change

- **WHEN** generating tasks across multiple files
- **THEN** all task IDs SHALL be unique within the change
- **AND** parent-child relationships SHALL be explicit via dot notation

### Requirement: Task Status Aggregation

The system SHALL compute aggregate status for reference tasks based on their children.

#### Scenario: All children pending

- **WHEN** all child tasks have status "pending"
- **THEN** the parent reference task SHALL have status "pending"

#### Scenario: Any child in progress

- **WHEN** at least one child task has status "in_progress"
- **THEN** the parent reference task SHALL have status "in_progress"

#### Scenario: All children completed

- **WHEN** all child tasks have status "completed"
- **THEN** the parent reference task SHALL have status "completed"

#### Scenario: Mixed pending and completed

- **WHEN** some children are "completed" and others are "pending" (none "in_progress")
- **THEN** the parent reference task SHALL have status "in_progress"

### Requirement: JSONC Format Validation

The system SHALL generate valid JSONC files with proper handling of special
characters and JSONC syntax features.

#### Scenario: Proper quote escaping in task descriptions

- **WHEN** a task description contains quotes (e.g., 'Fix "quoted string" in code')
- **THEN** quotes SHALL be properly escaped in the JSONC output
- **AND** the output file SHALL be valid JSONC that can be parsed without errors
- **AND** the description SHALL render correctly when read back

#### Scenario: JSONC trailing commas

- **WHEN** generating tasks.jsonc files
- **THEN** trailing commas in JSON arrays and objects MAY be used
- **AND** the output SHALL be valid JSONC format
- **AND** the system SHALL validate the output before writing

#### Scenario: Comment preservation in headers

- **WHEN** writing tasks.jsonc files with header comments
- **THEN** header comments SHALL use JSONC `//` syntax
- **AND** the comments SHALL precede the JSON object
- **AND** the entire file SHALL be valid JSONC

#### Scenario: Validation of generated files

- **WHEN** writing a tasks.jsonc file
- **THEN** the system SHALL validate the output is valid JSONC
- **AND** if validation fails, the write operation SHALL error with descriptive message
- **AND** no partial/invalid files SHALL be left on disk

### Requirement: Backwards Compatibility

The system SHALL maintain full compatibility with version 1 flat tasks.jsonc files.

#### Scenario: Read version 1 files

- **WHEN** reading a tasks.jsonc with `version: 1`
- **THEN** the system SHALL parse it as a flat task list
- **AND** no split file lookup SHALL be performed

#### Scenario: Generate version 1 for small files

- **WHEN** tasks.md is 100 lines or fewer
- **THEN** generate version 1 tasks.jsonc
- **AND** use existing flat structure without hierarchical fields

#### Scenario: Upgrade from version 1 to version 2

- **WHEN** running accept on a change with version 1 tasks.jsonc where tasks.md now
  exceeds 100 lines
- **THEN** the system SHALL regenerate as version 2 with split files
- **AND** preserve existing task statuses where IDs match
