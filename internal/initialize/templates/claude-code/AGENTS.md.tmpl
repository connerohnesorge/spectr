# Spectr Instructions

Instructions for Claude Code using Spectr for spec-driven development.

## TL;DR Quick Checklist

- Search existing work: Use `Glob` to find files in `{{ .ChangesDir }}/` and `{{ .SpecsDir }}/`, use `Grep` for content search
- Decide scope: new capability vs modify existing capability
- Pick a unique `change-id`: kebab-case, verb-led (`add-`, `update-`, `remove-`, `refactor-`)
- Scaffold: `proposal.md`, `tasks.md`, `design.md` (only if needed), and delta specs per affected capability
- Write deltas: use `## ADDED|MODIFIED|REMOVED|RENAMED Requirements`; include at least one `#### Scenario:` per requirement
- Validate: `spectr validate [change-id] --strict` and fix issues
- Request approval: Do not start implementation until proposal is approved

## Two-Stage Workflow

### Stage 1: Creating Changes
Create proposal when you need to:
- Add features or functionality
- Make breaking changes (API, schema)
- Change architecture or patterns
- Optimize performance (changes behavior)
- Update security patterns

Loose matching guidance:
- Contains one of: `proposal`, `change`, `spec`
- With one of: `create`, `plan`, `make`, `start`, `help`

Skip proposal for:
- Bug fixes (restore intended behavior)
- Typos, formatting, comments
- Dependency updates (non-breaking)
- Configuration changes
- Tests for existing behavior

Workflow:
1. Use `Read` to view `{{ .ProjectFile }}`. Use `Glob` to list files in `{{ .SpecsDir }}/` and `{{ .ChangesDir }}/` directories.
2. Choose a unique verb-led `change-id` and scaffold `proposal.md`, `tasks.md`, optional `design.md`, and spec deltas under `{{ .ChangesDir }}/<id>/`.
3. Draft spec deltas using `## ADDED|MODIFIED|REMOVED Requirements` with at least one `#### Scenario:` per requirement.
4. Run `spectr validate <id> --strict` via Bash and resolve any issues before sharing the proposal.

### Stage 2: Implementing Changes
Use TodoWrite to track implementation progress:
1. Read proposal.md - Use `Read` to understand what's being built
2. Read design.md (if exists) - Use `Read` to review technical decisions
3. Read tasks.md - Use `Read` to get implementation checklist
4. Implement tasks sequentially - Complete in order using `Edit` and `Write` tools
5. Confirm completion - Ensure every item in `tasks.md` is finished before updating statuses
6. Update checklist - After all work is done, set every task to `- [x]` so the list reflects reality
7. Approval gate - Do not start implementation until the proposal is reviewed and approved

## Claude Code Tool Reference

### Finding Files and Content

| Task | Tool | Example |
|------|------|---------|
| Find files by pattern | `Glob` | `Glob` with pattern `**/*.md` in `{{ .SpecsDir }}/` |
| Search code content | `Grep` | `Grep` for `"Requirement:\|Scenario:"` in `{{ .SpecsDir }}/` |
| Read specific file | `Read` | `Read` file at `{{ .SpecsDir }}/auth/spec.md` |
| Multi-step investigation | `Task` | Delegate to `explore` subagent for complex searches |

### Modifying Files

| Task | Tool | Usage |
|------|------|-------|
| Edit existing file | `Edit` | Replace specific text with `old_string` and `new_string` |
| Create new file | `Write` | Write complete file content to path |
| Run shell commands | `Bash` | Execute `spectr validate`, `spectr list`, etc. |

### Delegation with Task Tool

For complex investigations, delegate to subagents:
- Use `Task` with `explore` agent for multi-file searches
- Use `Task` with `coder` agent for implementation tasks
- Use `Task` with `tester` agent for verification

## Before Any Task

Context Checklist (use these tools):
- [ ] `Read` relevant specs in `{{ .SpecsDir }}/[capability]/spec.md`
- [ ] `Glob` for `*/proposal.md` in `{{ .ChangesDir }}/` to check pending changes
- [ ] `Read` the `{{ .ProjectFile }}` for conventions
- [ ] `Glob` for `*` in `{{ .ChangesDir }}/` to see active change directories
- [ ] `Glob` for `*` in `{{ .SpecsDir }}/` to see existing capability directories

Before Creating Specs:
- Always use `Glob` to check if capability already exists in `{{ .SpecsDir }}/`
- Prefer modifying existing specs over creating duplicates
- Use `Read` on `{{ .SpecsDir }}/<capability>/spec.md` to review current state
- If request is ambiguous, ask 1-2 clarifying questions before scaffolding

### Search Guidance

- Enumerate specs: `Glob` pattern `*/spec.md` in `{{ .SpecsDir }}/`
- Enumerate changes: `Glob` pattern `*/proposal.md` in `{{ .ChangesDir }}/`
- Read details directly:
  - Spec: `Read` file `{{ .SpecsDir }}/<capability>/spec.md`
  - Change: `Read` file `{{ .ChangesDir }}/<change-id>/proposal.md`
- Full-text search: `Grep` pattern `"Requirement:|Scenario:"` in `{{ .SpecsDir }}/`

## Quick Start

### CLI Commands (via Bash tool)

```bash
# Essential commands
spectr list                  # List active changes
spectr list --specs          # List specifications
spectr validate [item]       # Validate changes or specs

# Project management
spectr init [path]           # Initialize or update instruction files

# Interactive mode
spectr validate              # Bulk validation mode

# Debugging
spectr validate [change] --strict
```

Reading Specs and Changes (use Read tool):
- Specs: `Read` file `{{ .SpecsDir }}/<capability>/spec.md`
- Changes: `Read` file `{{ .ChangesDir }}/<change-id>/proposal.md`
- Tasks: `Read` file `{{ .ChangesDir }}/<change-id>/tasks.md`

### Command Flags

- `--json` - Machine-readable output
- `--type change|spec` - Disambiguate items
- `--strict` - Comprehensive validation
- `--no-interactive` - Disable prompts

## Directory Structure

```
{{ .BaseDir }}/
├── project.md              # Project conventions
├── specs/                  # Current truth - what IS built
│   └── [capability]/       # Single focused capability
│       ├── spec.md         # Requirements and scenarios
│       └── design.md       # Technical patterns
├── changes/                # Proposals - what SHOULD change
│   ├── [change-name]/
│   │   ├── proposal.md     # Why, what, impact
│   │   ├── tasks.md        # Implementation checklist
│   │   ├── design.md       # Technical decisions (optional; see criteria)
│   │   └── specs/          # Delta changes
│   │       └── [capability]/
│   │           └── spec.md # ADDED/MODIFIED/REMOVED
│   └── archive/            # Completed changes
```

## Creating Change Proposals

### Decision Tree

```
New request?
├─ Bug fix restoring spec behavior? → Fix directly
├─ Typo/format/comment? → Fix directly
├─ New feature/capability? → Create proposal
├─ Breaking change? → Create proposal
├─ Architecture change? → Create proposal
└─ Unclear? → Create proposal (safer)
```

### Proposal Structure

1. Create directory: `{{ .ChangesDir }}/[change-id]/` (kebab-case, verb-led, unique)

2. Use `Write` to create proposal.md:
```markdown
# Change: [Brief description of change]

## Why
[1-2 sentences on problem/opportunity]

## What Changes
- [Bullet list of changes]
- [Mark breaking changes with BREAKING]

## Impact
- Affected specs: [list capabilities]
- Affected code: [key files/systems]
```

3. Create spec deltas using `Write`: `{{ .ChangesDir }}/[change-id]/specs/[capability]/spec.md`
```markdown
## ADDED Requirements
### Requirement: New Feature
The system SHALL provide...

#### Scenario: Success case
- WHEN user performs action
- THEN expected result

## MODIFIED Requirements
### Requirement: Existing Feature
[Complete modified requirement]

## REMOVED Requirements
### Requirement: Old Feature
Reason: [Why removing]
Migration: [How to handle]
```
If multiple capabilities are affected, create multiple delta files under `{{ .ChangesDir }}/[change-id]/specs/<capability>/spec.md`—one per capability.

4. Use `Write` to create tasks.md:
```markdown
## 1. Implementation
- [ ] 1.1 Create database schema
- [ ] 1.2 Implement API endpoint
- [ ] 1.3 Add frontend component
- [ ] 1.4 Write tests
```

5. Create design.md when needed:
Create `design.md` if any of the following apply; otherwise omit it:
- Cross-cutting change (multiple services/modules) or a new architectural pattern
- New external dependency or significant data model changes
- Security, performance, or migration complexity
- Ambiguity that benefits from technical decisions before coding

Minimal `design.md` skeleton (use `Write`):
```markdown
## Context
[Background, constraints, stakeholders]

## Goals / Non-Goals
- Goals: [...]
- Non-Goals: [...]

## Decisions
- Decision: [What and why]
- Alternatives considered: [Options + rationale]

## Risks / Trade-offs
- [Risk] → Mitigation

## Migration Plan
[Steps, rollback]

## Open Questions
- [...]
```

## Spec File Format

### Critical: Scenario Formatting

CORRECT (use #### headers):
```markdown
#### Scenario: User login success
- WHEN valid credentials provided
- THEN return JWT token
```

WRONG (don't use bullets or bold):
```markdown
- Scenario: User login  ❌
Scenario: User login     ❌
### Scenario: User login      ❌
```

Every requirement MUST have at least one scenario.

### Requirement Wording
- Use SHALL/MUST for normative requirements (avoid should/may unless intentionally non-normative)

### Delta Operations

- `## ADDED Requirements` - New capabilities
- `## MODIFIED Requirements` - Changed behavior
- `## REMOVED Requirements` - Deprecated features
- `## RENAMED Requirements` - Name changes

Headers matched with `trim(header)` - whitespace ignored.

#### When to use ADDED vs MODIFIED
- ADDED: Introduces a new capability or sub-capability that can stand alone as a requirement. Prefer ADDED when the change is orthogonal (e.g., adding "Slash Command Configuration") rather than altering the semantics of an existing requirement.
- MODIFIED: Changes the behavior, scope, or acceptance criteria of an existing requirement. Always paste the full, updated requirement content (header + all scenarios). The archiver will replace the entire requirement with what you provide here; partial deltas will drop previous details.
- RENAMED: Use when only the name changes. If you also change behavior, use RENAMED (name) plus MODIFIED (content) referencing the new name.

Common pitfall: Using MODIFIED to add a new concern without including the previous text. This causes loss of detail at archive time. If you aren't explicitly changing the existing requirement, add a new requirement under ADDED instead.

Authoring a MODIFIED requirement correctly:
1) Use `Read` to locate the existing requirement in `{{ .SpecsDir }}/<capability>/spec.md`.
2) Copy the entire requirement block (from `### Requirement: ...` through its scenarios).
3) Paste it under `## MODIFIED Requirements` and edit to reflect the new behavior.
4) Ensure the header text matches exactly (whitespace-insensitive) and keep at least one `#### Scenario:`.

Example for RENAMED:
```markdown
## RENAMED Requirements
- FROM: `### Requirement: Login`
- TO: `### Requirement: User Authentication`
```

## Troubleshooting

### Common Errors

"Change must have at least one delta"
- Use `Glob` to check `{{ .ChangesDir }}/[name]/specs/` exists with .md files
- Use `Read` to verify files have operation prefixes (## ADDED Requirements)

"Requirement must have at least one scenario"
- Check scenarios use `#### Scenario:` format (4 hashtags)
- Don't use bullet points or bold for scenario headers

Silent scenario parsing failures
- Exact format required: `#### Scenario: Name`
- Debug by using `Read` on the delta spec file: `{{ .ChangesDir }}/<change-id>/specs/<capability>/spec.md`

### Validation Tips

```bash
# Always use strict mode for comprehensive checks
spectr validate [change] --strict
```

For validation debugging:
- Use `Read` on delta specs: `{{ .ChangesDir }}/<change-id>/specs/<capability>/spec.md`
- Use `Read` on spec content: `{{ .SpecsDir }}/<capability>/spec.md`

## Happy Path Script

Using Claude Code tools:

```
# 1) Explore current state
Bash: spectr spec list --long
Bash: spectr list
# Optional full-text search:
# Grep: pattern "Requirement:|Scenario:" in {{ .SpecsDir }}/
# Grep: pattern "^#|Requirement:" in {{ .ChangesDir }}/

# 2) Choose change id and scaffold
CHANGE=add-two-factor-auth
Bash: mkdir -p {{ .ChangesDir }}/$CHANGE/specs/auth

# 3) Create proposal.md
Write: {{ .ChangesDir }}/$CHANGE/proposal.md
Content: "## Why\n...\n\n## What Changes\n- ...\n\n## Impact\n- ..."

# 4) Create tasks.md
Write: {{ .ChangesDir }}/$CHANGE/tasks.md
Content: "## 1. Implementation\n- [ ] 1.1 ..."

# 5) Create delta spec
Write: {{ .ChangesDir }}/$CHANGE/specs/auth/spec.md
Content:
## ADDED Requirements
### Requirement: Two-Factor Authentication
Users MUST provide a second factor during login.

#### Scenario: OTP required
- WHEN valid credentials are provided
- THEN an OTP challenge is required

# 6) Validate
Bash: spectr validate $CHANGE --strict
```

## Multi-Capability Example

```
{{ .ChangesDir }}/add-2fa-notify/
├── proposal.md
├── tasks.md
└── specs/
    ├── auth/
    │   └── spec.md   # ADDED: Two-Factor Authentication
    └── notifications/
        └── spec.md   # ADDED: OTP email notification
```

auth/spec.md
```markdown
## ADDED Requirements
### Requirement: Two-Factor Authentication
...
```

notifications/spec.md
```markdown
## ADDED Requirements
### Requirement: OTP Email Notification
...
```

## Best Practices

### Simplicity First
- Default to <100 lines of new code
- Single-file implementations until proven insufficient
- Avoid frameworks without clear justification
- Choose boring, proven patterns

### Complexity Triggers
Only add complexity with:
- Performance data showing current solution too slow
- Concrete scale requirements (>1000 users, >100MB data)
- Multiple proven use cases requiring abstraction

### Clear References
- Use `file.ts:42` format for code locations
- Reference specs as `{{ .SpecsDir }}/auth/spec.md`
- Link related changes and PRs

### Capability Naming
- Use verb-noun: `user-auth`, `payment-capture`
- Single purpose per capability
- 10-minute understandability rule
- Split if description needs "AND"

### Change ID Naming
- Use kebab-case, short and descriptive: `add-two-factor-auth`
- Prefer verb-led prefixes: `add-`, `update-`, `remove-`, `refactor-`
- Ensure uniqueness; if taken, append `-2`, `-3`, etc.

## Claude Code Tool Selection Guide

| Task | Tool | Why |
|------|------|-----|
| Find files by pattern | `Glob` | Fast pattern matching across directories |
| Search code content | `Grep` | Optimized regex search with file filtering |
| Read specific files | `Read` | Direct file access, supports images and PDFs |
| Create/overwrite files | `Write` | Write complete file content |
| Edit existing files | `Edit` | Precise text replacement with context |
| Run commands | `Bash` | Execute spectr CLI, git, etc. |
| Complex investigation | `Task` | Delegate to explore subagent |
| Track work items | `TodoWrite` | Manage implementation checklist |

## Error Recovery

### Change Conflicts
1. Use `Glob` pattern `*/proposal.md` in `{{ .ChangesDir }}/` to see active changes
2. Use `Grep` to check for overlapping specs
3. Coordinate with change owners
4. Consider combining proposals

### Validation Failures
1. Run with `--strict` flag via Bash
2. Check JSON output for details
3. Use `Read` to verify spec file format
4. Ensure scenarios properly formatted

### Missing Context
1. Use `Read` on project.md first
2. Use `Read` on related specs
3. Use `Glob` to find files in archives
4. Ask for clarification

## Quick Reference

### Stage Indicators
- `{{ .ChangesDir }}/` - Proposed, not yet built
- `{{ .SpecsDir }}/` - Built and deployed
- `{{ .ChangesDir }}/archive/` - Completed changes

### File Purposes
- `proposal.md` - Why and what
- `tasks.md` - Implementation steps
- `spec.md` - Requirements and behavior
- `design.md` - Technical decisions (optional)

### CLI Essentials (via Bash)
```bash
spectr list              # What's in progress?
spectr validate --strict # Is it correct?
spectr archive <change-id> [--yes|-y]  # Mark complete (add --yes for automation)
```

Reading Details (use Claude Code tools):
- `Read` file `{{ .SpecsDir }}/<capability>/spec.md` for spec details
- `Read` file `{{ .ChangesDir }}/<change-id>/proposal.md` for change details

Remember: Specs are truth. Changes are proposals. Keep them in sync.
