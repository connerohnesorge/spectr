// Package cmd provides command-line interface implementations.
// This file contains JSONC validation functions for the accept command.
//
// The validator ensures that tasks.jsonc files generated by `spectr accept`
// are valid JSONC format and can be successfully parsed back. This is critical
// because task descriptions may contain special characters (backslashes, quotes,
// unicode, newlines, etc.) that require proper escaping.
//
// Key Functions:
//   - validateJSONCOutput: Verifies that generated JSONC can be parsed back
//   - validateTasksJSONC: Performs round-trip validation for tasks.jsonc files
//   - validateRoundTrip: Ensures Task → JSONC → Task produces identical results
//
// The validation strategy includes:
//  1. Syntactic validation: Verify JSONC can be parsed by a JSONC parser
//  2. Round-trip validation: Ensure data integrity through marshal/unmarshal cycles
//  3. Escape sequence verification: Check that special characters are properly encoded
//
// This defensive validation prevents bugs where tasks.jsonc is written successfully
// but fails to parse correctly during subsequent `spectr accept` regeneration or
// when read by other commands.
//
//nolint:revive // file-length-limit: validation logic requires comprehensive checks
package cmd

import (
	"encoding/json"
	"errors"
	"fmt"
	"strings"

	"github.com/connerohnesorge/spectr/internal/parsers"
)

// validateJSONCOutput verifies that generated JSONC can be parsed back successfully.
// This function validates the syntactic correctness of JSONC output by:
//  1. Stripping JSONC comments using parsers.StripJSONComments
//  2. Unmarshalling the stripped JSON into a generic interface{}
//  3. Returning detailed error information if parsing fails
//
// Parameters:
//   - jsonData: The raw JSONC bytes to validate
//
// Returns:
//   - nil if the JSONC is valid and can be parsed
//   - error with position and context if parsing fails
//
// This validation is critical because task descriptions may contain special
// characters (backslashes, quotes, unicode, newlines) that require proper
// JSON escaping. We must ensure the generated JSONC can be read back
// correctly by subsequent commands.
//
//nolint:unused // Will be used in tasks 2.4-2.6 when wired into accept_writer.go
func validateJSONCOutput(jsonData []byte) error {
	// Strip JSONC comments to get pure JSON
	stripped := parsers.StripJSONComments(jsonData)

	// Attempt to unmarshal into generic interface
	var result interface{}
	if err := json.Unmarshal(stripped, &result); err != nil {
		// Build detailed error message with context
		return buildJSONCValidationError(stripped, err)
	}

	return nil
}

// buildJSONCValidationError creates a detailed error message for JSONC validation failures.
// It extracts information from the JSON parsing error and provides helpful context including:
//   - The problematic content around the error location
//   - The exact parse error and position
//   - Suggestions for common fixes
//
// Parameters:
//   - jsonData: The JSON data that failed to parse
//   - parseErr: The error returned by json.Unmarshal
//
// Returns:
//   - A detailed error with context and suggestions
func buildJSONCValidationError(jsonData []byte, parseErr error) error {
	var syntaxErr *json.SyntaxError

	// Build the base error message
	var errorMsg strings.Builder
	errorMsg.WriteString("JSONC validation failed: ")

	// Check if it's a syntax error to extract position information
	if errors.As(parseErr, &syntaxErr) {
		// Add the parse error message
		errorMsg.WriteString(parseErr.Error())
		errorMsg.WriteString("\n\n")

		// Show context around the error position
		offset := syntaxErr.Offset
		if offset >= 0 && offset <= int64(len(jsonData)) {
			errorMsg.WriteString("Problematic content near position ")
			errorMsg.WriteString(fmt.Sprintf("%d", offset))
			errorMsg.WriteString(":\n")

			// Show surrounding context (up to 100 chars before and after)
			const contextSize = 100
			start := int64(0)
			if offset > contextSize {
				start = offset - contextSize
				errorMsg.WriteString("...")
			}

			end := offset + contextSize
			if end > int64(len(jsonData)) {
				end = int64(len(jsonData))
			}

			// Extract and display the context
			context := string(jsonData[start:end])
			if end < int64(len(jsonData)) {
				context += "..."
			}

			// Escape control characters for display
			context = strings.ReplaceAll(context, "\n", "\\n")
			context = strings.ReplaceAll(context, "\t", "\\t")
			context = strings.ReplaceAll(context, "\r", "\\r")

			errorMsg.WriteString(context)
			errorMsg.WriteString("\n\n")
		}
	} else {
		// For non-syntax errors, just include the error message
		errorMsg.WriteString(parseErr.Error())
		errorMsg.WriteString("\n\n")
	}

	// Add helpful suggestions
	errorMsg.WriteString("Common causes:\n")
	errorMsg.WriteString("  - Task descriptions with unescaped special characters (backslashes, quotes)\n")
	errorMsg.WriteString("  - Unicode characters that weren't properly encoded\n")
	errorMsg.WriteString("  - Newlines or control characters in task descriptions\n")
	errorMsg.WriteString("\n")
	errorMsg.WriteString("This indicates a bug in JSON escaping. The generated tasks.jsonc file contains malformed JSON.")

	return fmt.Errorf("%s", errorMsg.String())
}

// validateTasksJSONC performs round-trip validation of tasks.jsonc files.
// It ensures that marshaling a TasksFile to JSON and unmarshaling it back
// produces an identical structure, verifying that no data is lost during
// serialization.
//
// Round-trip validation strategy:
//  1. Parse the JSONC data back into a new TasksFile struct
//  2. Compare all critical fields between original and parsed structs
//  3. Check version, parent, includes, and all task fields (ID, description, status, etc.)
//  4. Return detailed error if any field doesn't match
//  5. Return nil if round-trip is lossless
//
// This validation catches issues where special characters in task descriptions
// (backslashes, quotes, newlines, unicode) are incorrectly escaped during JSON
// marshaling, causing data corruption when the file is read back.
//
// Parameters:
//   - tasksFile: The original TasksFile struct that was marshaled to JSON
//   - jsonData: The raw JSONC bytes (with comments) to validate
//
// Returns:
//   - nil if round-trip validation passes
//   - error with details about which fields don't match if validation fails
//
//nolint:unused // Will be used in tasks 2.4-2.6 when wired into accept_writer.go
func validateTasksJSONC(tasksFile parsers.TasksFile, jsonData []byte) error {
	// Strip JSONC comments before parsing
	cleanJSON := parsers.StripJSONComments(jsonData)

	// Parse JSONC back into TasksFile struct
	var parsed parsers.TasksFile
	if err := json.Unmarshal(cleanJSON, &parsed); err != nil {
		return fmt.Errorf("round-trip validation failed: cannot unmarshal JSONC: %w", err)
	}

	// Validate version field
	if tasksFile.Version != parsed.Version {
		return fmt.Errorf(
			"round-trip validation failed: version mismatch (expected %d, got %d)",
			tasksFile.Version,
			parsed.Version,
		)
	}

	// Validate parent field (if present)
	if tasksFile.Parent != parsed.Parent {
		return fmt.Errorf(
			"round-trip validation failed: parent mismatch (expected %q, got %q)",
			tasksFile.Parent,
			parsed.Parent,
		)
	}

	// Validate includes field (if present)
	// Use simple slice comparison instead of reflect.DeepEqual
	if len(tasksFile.Includes) != len(parsed.Includes) {
		return fmt.Errorf(
			"round-trip validation failed: includes length mismatch (expected %d, got %d)",
			len(tasksFile.Includes),
			len(parsed.Includes),
		)
	}
	for i := range tasksFile.Includes {
		if tasksFile.Includes[i] != parsed.Includes[i] {
			return fmt.Errorf(
				"round-trip validation failed: includes[%d] mismatch (expected %q, got %q)",
				i,
				tasksFile.Includes[i],
				parsed.Includes[i],
			)
		}
	}

	// Validate tasks array length
	if len(tasksFile.Tasks) != len(parsed.Tasks) {
		return fmt.Errorf(
			"round-trip validation failed: tasks array length mismatch (expected %d, got %d)",
			len(tasksFile.Tasks),
			len(parsed.Tasks),
		)
	}

	// Validate each task field-by-field
	for i := range tasksFile.Tasks {
		original := tasksFile.Tasks[i]
		roundTripped := parsed.Tasks[i]

		// Check task ID
		if original.ID != roundTripped.ID {
			return fmt.Errorf(
				"round-trip validation failed: task[%d].id mismatch (expected %q, got %q)",
				i,
				original.ID,
				roundTripped.ID,
			)
		}

		// Check task section
		if original.Section != roundTripped.Section {
			return fmt.Errorf(
				"round-trip validation failed: task[%d].section mismatch (expected %q, got %q)",
				i,
				original.Section,
				roundTripped.Section,
			)
		}

		// Check task description (critical for special character handling)
		if original.Description != roundTripped.Description {
			return fmt.Errorf(
				"round-trip validation failed: task[%d].description mismatch\nExpected: %q\nGot: %q",
				i,
				original.Description,
				roundTripped.Description,
			)
		}

		// Check task status
		if original.Status != roundTripped.Status {
			return fmt.Errorf(
				"round-trip validation failed: task[%d].status mismatch (expected %q, got %q)",
				i,
				original.Status,
				roundTripped.Status,
			)
		}

		// Check task children reference (if present)
		if original.Children != roundTripped.Children {
			return fmt.Errorf(
				"round-trip validation failed: task[%d].children mismatch (expected %q, got %q)",
				i,
				original.Children,
				roundTripped.Children,
			)
		}
	}

	// Round-trip validation successful
	return nil
}
