// Package cmd provides command-line interface implementations.
// This file contains the JSONC writer for the accept command.
//
//nolint:revive // file-length-limit: accept_writer requires comprehensive task writing logic
package cmd

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/connerohnesorge/spectr/internal/config"
	"github.com/connerohnesorge/spectr/internal/parsers"
)

// tasksJSONHeader is the comprehensive JSONC comment header prepended to
// tasks.jsonc files. It explains status values, transitions, and workflow.
const tasksJSONHeader = `// Spectr Tasks File (JSONC)
//
// This file contains machine-readable task definitions for a Spectr change.
// JSONC format allows comments while maintaining JSON compatibility.
//
// Status Values:
//   - "pending"     : Task has not been started yet
//   - "in_progress" : Task is currently being worked on
//   - "completed"   : Task has been finished and verified
//
// Status Transitions:
//   pending -> in_progress -> completed
//
//   Tasks should only move forward through these states.
//   Do not skip states or move backward.
//
// Workflow:
//   1. BEFORE starting work on a task, mark it as "in_progress"
//   2. Complete the implementation for the task
//   3. Verify the work is correct and complete
//   4. IMMEDIATELY mark the task as "completed" after verification
//   5. Move to the next task and repeat
//
// IMPORTANT - Update Status Immediately:
//   - Update each task's status IMMEDIATELY after it transitions
//   - Do NOT batch status updates at the end of all work
//   - Do NOT wait until all tasks are done to update statuses
//   - This file should reflect accurate progress at any point in time
//   - Using a single edit to mark a task completed AND the next task
//     in_progress is allowed (this is a single transition, not batching)
//
// Note: This file is auto-generated by 'spectr accept'. Manual edits to
// task status are expected, but structure changes may be overwritten.
// The original tasks.md file is preserved alongside tasks.jsonc to retain
// human-readable formatting, links, and context.
//

`

// childFileHeader generates a JSONC header for child task files (tasks-N.jsonc).
// It includes origin information (change ID, parent task ID) followed by the
// full standard header that explains status values, transitions, and workflow.
//
// This provides context when an agent reads a child file standalone, enabling
// them to understand where the file came from and how to work with task statuses.
//
// Parameters:
//   - changeID: The ID of the change (e.g., "add-size-based-task-splitting")
//   - parentTaskID: The ID of the parent task in the root file (e.g., "5")
//
// Returns a complete JSONC header string with trailing newlines.
func childFileHeader(changeID, parentTaskID string) string {
	return fmt.Sprintf(`// Generated by: spectr accept %s
// Parent change: %s
// Parent task: %s
//
// This file contains child tasks split from the main tasks.jsonc for readability.
// JSONC format allows comments while maintaining JSON compatibility.
//
// Status Values:
//   - "pending"     : Task has not been started yet
//   - "in_progress" : Task is currently being worked on
//   - "completed"   : Task has been finished and verified
//
// Status Transitions:
//   pending -> in_progress -> completed
//
//   Tasks should only move forward through these states.
//   Do not skip states or move backward.
//
// Workflow:
//   1. BEFORE starting work on a task, mark it as "in_progress"
//   2. Complete the implementation for the task
//   3. Verify the work is correct and complete
//   4. IMMEDIATELY mark the task as "completed" after verification
//   5. Move to the next task and repeat
//
// IMPORTANT - Update Status Immediately:
//   - Update each task's status IMMEDIATELY after it transitions
//   - Do NOT batch status updates at the end of all work
//   - Do NOT wait until all tasks are done to update statuses
//   - This file should reflect accurate progress at any point in time
//   - Using a single edit to mark a task completed AND the next task
//     in_progress is allowed (this is a single transition, not batching)
//
// Note: This file is auto-generated by 'spectr accept'. Manual edits to
// task status are expected, but structure changes may be overwritten.
// To see the parent task or other sections, refer to the root tasks.jsonc file.
//

`, changeID, changeID, parentTaskID)
}

// writeTasksJSONC writes tasks to a tasks.jsonc file with header.
// Prepends tasksJSONHeader to the JSON data (see parsers/types.go).
// If appendCfg is provided, appends configured tasks with sequential IDs.
// If statusMap is provided, preserves statuses for tasks with matching IDs.
func writeTasksJSONC(
	path string,
	tasks []parsers.Task,
	appendCfg *config.AppendTasksConfig,
	statusMap map[string]parsers.TaskStatusValue,
) error {
	// Merge old statuses with new tasks (preserves status during regeneration)
	mergedTasks := mergeTaskStatuses(tasks, statusMap)

	// Append configured tasks if present
	allTasks := mergedTasks
	if appendCfg != nil && appendCfg.HasTasks() {
		appendedTasks := createAppendedTasks(mergedTasks, appendCfg)
		allTasks = append(allTasks, appendedTasks...)
	}

	tasksFile := parsers.TasksFile{
		Version: 1,
		Tasks:   allTasks,
	}

	jsonData, err := json.MarshalIndent(
		tasksFile,
		"",
		"  ",
	)
	if err != nil {
		return fmt.Errorf(
			"failed to marshal tasks to JSON: %w",
			err,
		)
	}

	// Prepend the JSONC header to the JSON data
	output := tasksJSONHeader + string(jsonData)

	// Validate JSONC output BEFORE writing to disk (fail fast)
	if err := validateJSONCOutput([]byte(output)); err != nil {
		return fmt.Errorf("JSONC validation failed before writing %s: %w", path, err)
	}

	// Validate round-trip integrity (ensures no data loss during serialization)
	if err := validateTasksJSONC(tasksFile, []byte(output)); err != nil {
		return fmt.Errorf("round-trip validation failed for %s: %w", path, err)
	}

	if err := os.WriteFile(path, []byte(output), filePerm); err != nil {
		return fmt.Errorf(
			"failed to write tasks.jsonc: %w",
			err,
		)
	}

	return nil
}

// createAppendedTasks creates Task structs from the append config.
// It generates sequential task IDs continuing from the last existing task.
// For example, if the last task ID was 3.2, appended tasks start at 4.1.
func createAppendedTasks(
	existingTasks []parsers.Task,
	cfg *config.AppendTasksConfig,
) []parsers.Task {
	nextSectionNum := findNextSectionNumber(existingTasks)
	section := cfg.GetSection()

	tasks := make([]parsers.Task, 0, len(cfg.Tasks))
	for i, desc := range cfg.Tasks {
		taskID := fmt.Sprintf("%d.%d", nextSectionNum, i+1)
		tasks = append(tasks, parsers.Task{
			ID:          taskID,
			Section:     section,
			Description: desc,
			Status:      parsers.TaskStatusPending,
		})
	}

	return tasks
}

// findNextSectionNumber determines the next section number for appended tasks.
// It parses existing task IDs to find the highest section number, then adds 1.
// Returns 1 if no existing tasks or task IDs are not in expected format.
func findNextSectionNumber(tasks []parsers.Task) int {
	maxSection := 0
	for _, task := range tasks {
		// Parse section number from task ID (e.g., "3.2" -> 3)
		parts := strings.Split(task.ID, ".")
		if len(parts) < 1 {
			continue
		}
		sectionNum, err := strconv.Atoi(parts[0])
		if err != nil {
			continue
		}
		if sectionNum > maxSection {
			maxSection = sectionNum
		}
	}

	return maxSection + 1
}

// computeAggregateStatus computes the aggregate status of a parent task
// based on the statuses of its children.
//
// Aggregation rules (from Decision 6: Status Aggregation):
//   - All children "pending" → parent "pending"
//   - Any child "in_progress" → parent "in_progress"
//   - All children "completed" → parent "completed"
//   - Mixed "pending" + "completed" (no "in_progress") → parent "in_progress"
//
// If there are no children, returns "pending" by default.
func computeAggregateStatus(children []parsers.Task) parsers.TaskStatusValue {
	if len(children) == 0 {
		return parsers.TaskStatusPending
	}

	// Count status occurrences
	var pendingCount, inProgressCount, completedCount int
	for _, child := range children {
		switch child.Status {
		case parsers.TaskStatusPending:
			pendingCount++
		case parsers.TaskStatusInProgress:
			inProgressCount++
		case parsers.TaskStatusCompleted:
			completedCount++
		}
	}

	// Rule 1: Any child "in_progress" → parent "in_progress"
	if inProgressCount > 0 {
		return parsers.TaskStatusInProgress
	}

	// Rule 2: All children "completed" → parent "completed"
	if completedCount == len(children) {
		return parsers.TaskStatusCompleted
	}

	// Rule 3: All children "pending" → parent "pending"
	if pendingCount == len(children) {
		return parsers.TaskStatusPending
	}

	// Rule 4: Mixed "pending" + "completed" (no "in_progress") → parent "in_progress"
	// This is the catch-all for partial completion
	return parsers.TaskStatusInProgress
}

// loadExistingStatuses reads existing tasks.jsonc files and builds a map of task ID → status.
// This is used during regeneration to preserve task statuses when IDs match.
//
// The function reads both the root tasks.jsonc and any child tasks-*.jsonc files,
// extracting the status of each task by its ID. When a tasks.md file is regenerated
// via `spectr accept`, this map is used to preserve existing statuses for tasks
// whose IDs haven't changed.
//
// Parameters:
//   - changeDir: The directory containing the tasks.jsonc files
//
// Returns a map[taskID]status and any error encountered during reading.
// Returns an empty map if no existing tasks.jsonc files are found (not an error).
func loadExistingStatuses(changeDir string) (map[string]parsers.TaskStatusValue, error) {
	statusMap := make(map[string]parsers.TaskStatusValue)

	// Load root file statuses
	rootTasks, err := loadRootTasksFile(changeDir)
	if err != nil {
		return nil, err
	}

	if rootTasks == nil {
		// No file exists - return empty map
		return statusMap, nil
	}

	// Add root file tasks to the map
	addTaskStatusesToMap(statusMap, rootTasks.Tasks)

	// If this is a version 2 file, also read child files
	// Version 1 files don't have child files, so we only load them for version 2
	if isVersionTwo(rootTasks) && len(rootTasks.Includes) > 0 {
		if err := loadChildFileStatuses(changeDir, statusMap); err != nil {
			return nil, err
		}
	}

	return statusMap, nil
}

// isVersionTwo checks if a TasksFile uses the version 2 hierarchical format.
// Version 2 is indicated by the version field being set to 2.
// This function is used to determine whether to read child files or not.
//
// Parameters:
//   - tasksFile: The parsed TasksFile to check
//
// Returns true if the file uses version 2 format, false otherwise.
func isVersionTwo(tasksFile *parsers.TasksFile) bool {
	return tasksFile != nil && tasksFile.Version == 2
}

// loadRootTasksFile reads and parses the root tasks.jsonc file.
// Returns nil if the file doesn't exist (not an error).
func loadRootTasksFile(changeDir string) (*parsers.TasksFile, error) {
	rootPath := fmt.Sprintf("%s/tasks.jsonc", changeDir)
	rootFile, err := os.ReadFile(rootPath)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil
		}

		return nil, fmt.Errorf("failed to read tasks.jsonc: %w", err)
	}

	// Strip JSONC comments before parsing
	strippedRoot := parsers.StripJSONComments(rootFile)

	var rootTasks parsers.TasksFile
	if err := json.Unmarshal(strippedRoot, &rootTasks); err != nil {
		return nil, fmt.Errorf("failed to parse tasks.jsonc: %w", err)
	}

	return &rootTasks, nil
}

// loadChildFileStatuses reads all child tasks-*.jsonc files and adds their statuses to the map.
func loadChildFileStatuses(changeDir string, statusMap map[string]parsers.TaskStatusValue) error {
	childFiles, err := os.ReadDir(changeDir)
	if err != nil {
		return fmt.Errorf("failed to read change directory: %w", err)
	}

	for _, file := range childFiles {
		if !isChildTasksFile(file) {
			continue
		}

		if err := loadSingleChildFile(changeDir, file.Name(), statusMap); err != nil {
			return err
		}
	}

	return nil
}

// isChildTasksFile checks if a file is a child tasks file (tasks-*.jsonc).
func isChildTasksFile(file os.DirEntry) bool {
	if file.IsDir() || file.Name() == "tasks.jsonc" {
		return false
	}

	return strings.HasPrefix(file.Name(), "tasks-") && strings.HasSuffix(file.Name(), ".jsonc")
}

// loadSingleChildFile reads and parses a single child tasks file.
func loadSingleChildFile(
	changeDir, fileName string,
	statusMap map[string]parsers.TaskStatusValue,
) error {
	childPath := fmt.Sprintf("%s/%s", changeDir, fileName)
	childData, err := os.ReadFile(childPath)
	if err != nil {
		return fmt.Errorf("failed to read %s: %w", fileName, err)
	}

	// Strip JSONC comments before parsing
	strippedChild := parsers.StripJSONComments(childData)

	var childTasks parsers.TasksFile
	if err := json.Unmarshal(strippedChild, &childTasks); err != nil {
		return fmt.Errorf("failed to parse %s: %w", fileName, err)
	}

	// Add child file tasks to the map
	addTaskStatusesToMap(statusMap, childTasks.Tasks)

	return nil
}

// addTaskStatusesToMap adds task statuses from a slice of tasks to the status map.
func addTaskStatusesToMap(statusMap map[string]parsers.TaskStatusValue, tasks []parsers.Task) {
	for _, task := range tasks {
		statusMap[task.ID] = task.Status
	}
}

// mergeTaskStatuses merges old task statuses into new tasks based on ID matching.
// For tasks whose IDs exist in the statusMap, the old status is preserved.
// For new tasks (IDs not in statusMap), the status remains "pending".
//
// This function is called during regeneration to preserve work progress when
// re-running `spectr accept`. Only tasks with matching IDs have their status
// preserved - new tasks or tasks with changed IDs get "pending" status.
//
// Parameters:
//   - tasks: The new tasks parsed from tasks.md
//   - statusMap: Map of old task IDs to their statuses
//
// Returns the tasks with statuses merged from the map.
func mergeTaskStatuses(
	tasks []parsers.Task,
	statusMap map[string]parsers.TaskStatusValue,
) []parsers.Task {
	mergedTasks := make([]parsers.Task, len(tasks))

	for i, task := range tasks {
		mergedTasks[i] = task

		// If this task ID exists in the old status map, preserve its status
		if oldStatus, exists := statusMap[task.ID]; exists {
			mergedTasks[i].Status = oldStatus
		}
		// Otherwise, keep the default "pending" status from the parsed task
	}

	return mergedTasks
}

// deleteOldChildFiles removes all existing tasks-*.jsonc files in the change directory.
// This is called before regenerating split files to ensure a clean slate.
// The root tasks.jsonc file is NOT deleted.
//
// Parameters:
//   - changeDir: The directory containing the tasks files
//
// Returns an error if the directory cannot be read or files cannot be deleted.
func deleteOldChildFiles(changeDir string) error {
	entries, err := os.ReadDir(changeDir)
	if err != nil {
		return fmt.Errorf("failed to read change directory: %w", err)
	}

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}

		// Check if this is a child tasks file (tasks-*.jsonc)
		if !strings.HasPrefix(entry.Name(), "tasks-") ||
			!strings.HasSuffix(entry.Name(), ".jsonc") {
			continue
		}

		filePath := filepath.Join(changeDir, entry.Name())
		if err := os.Remove(filePath); err != nil {
			return fmt.Errorf("failed to delete %s: %w", entry.Name(), err)
		}
	}

	return nil
}

// writeRootTasksJSONC writes the root tasks.jsonc file with reference tasks.
// Reference tasks point to child task files using the "$ref:tasks-N.jsonc" syntax.
// The status of each reference task is computed from its children.
//
// Parameters:
//   - path: The path where the root tasks.jsonc will be written
//   - referenceTasks: Tasks that contain references to child files
//
// Returns an error if the file cannot be written.
func writeRootTasksJSONC(path string, referenceTasks []parsers.Task) error {
	tasksFile := parsers.TasksFile{
		Version:  2,
		Tasks:    referenceTasks,
		Includes: []string{"tasks-*.jsonc"},
	}

	jsonData, err := json.MarshalIndent(tasksFile, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal root tasks to JSON: %w", err)
	}

	// Prepend the JSONC header to the JSON data
	output := tasksJSONHeader + string(jsonData)

	// Validate JSONC output before writing to disk
	if err := validateJSONCOutput([]byte(output)); err != nil {
		return fmt.Errorf("validation failed for root tasks.jsonc: %w", err)
	}

	if err := os.WriteFile(path, []byte(output), filePerm); err != nil {
		return fmt.Errorf("failed to write root tasks.jsonc: %w", err)
	}

	return nil
}

// writeChildTasksJSONC writes a child tasks-N.jsonc file with a full header.
// The header includes origin information (change ID, parent task ID) followed
// by the standard task status documentation.
//
// Parameters:
//   - path: The path where the child file will be written (e.g., "tasks-1.jsonc")
//   - changeID: The ID of the change
//   - parentTaskID: The ID of the parent task in the root file
//   - tasks: The tasks to write to this child file
//
// Returns an error if the file cannot be written.
func writeChildTasksJSONC(path, changeID, parentTaskID string, tasks []parsers.Task) error {
	tasksFile := parsers.TasksFile{
		Version: 2,
		Parent:  parentTaskID,
		Tasks:   tasks,
	}

	jsonData, err := json.MarshalIndent(tasksFile, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal child tasks to JSON: %w", err)
	}

	// Validate JSONC output before writing to disk
	if err := validateJSONCOutput(jsonData); err != nil {
		return fmt.Errorf("validation failed for child tasks file %s: %w", path, err)
	}

	// Perform round-trip validation
	if err := validateTasksJSONC(tasksFile, jsonData); err != nil {
		return fmt.Errorf("round-trip validation failed for child tasks file %s: %w", path, err)
	}

	// Use the child-specific header with origin information
	header := childFileHeader(changeID, parentTaskID)
	output := header + string(jsonData)

	if err := os.WriteFile(path, []byte(output), filePerm); err != nil {
		return fmt.Errorf("failed to write child tasks file: %w", err)
	}

	return nil
}

// splitGroup represents a group of tasks that will be written to a single file.
// This can be either a whole section or a subsection group.
type splitGroup struct {
	parentID string         // Parent task ID for the reference task
	section  string         // Section name
	tasks    []parsers.Task // Tasks in this group
}

// writeHierarchicalTasks orchestrates the writing of hierarchical task files.
// It deletes old child files, creates reference tasks for each split group,
// writes the root tasks.jsonc with references, and writes each child file.
//
// This function is called when a tasks.md file exceeds the split threshold
// and needs to be split into multiple files for better readability.
//
// Parameters:
//   - changeDir: The directory containing the change
//   - changeID: The ID of the change
//   - sections: Parsed sections from tasks.md
//   - statusMap: Map of old task statuses for preservation
//
// Returns an error if any file operations fail.
func writeHierarchicalTasks(
	changeDir, changeID string,
	sections []Section,
	statusMap map[string]parsers.TaskStatusValue,
) error {
	// Step 1: Delete old child files
	if err := deleteOldChildFiles(changeDir); err != nil {
		return fmt.Errorf("failed to delete old child files: %w", err)
	}

	// Step 2: Determine split groups (sections or subsections)
	splitGroups := determineSplitGroups(sections)

	// Step 3: Merge statuses for all tasks
	var allTasks []parsers.Task
	for _, group := range splitGroups {
		allTasks = append(allTasks, group.tasks...)
	}
	mergedTasks := mergeTaskStatuses(allTasks, statusMap)

	// Rebuild split groups with merged statuses
	taskIndex := 0
	for i := range splitGroups {
		for j := range splitGroups[i].tasks {
			splitGroups[i].tasks[j] = mergedTasks[taskIndex]
			taskIndex++
		}
	}

	// Step 4: Create reference tasks for root file
	referenceTasks := make([]parsers.Task, len(splitGroups))
	for i, group := range splitGroups {
		// Compute aggregate status from children
		status := computeAggregateStatus(group.tasks)

		// Create reference task
		referenceTasks[i] = parsers.Task{
			ID:          group.parentID,
			Section:     group.section,
			Description: fmt.Sprintf("%s tasks", group.section),
			Status:      status,
			Children:    fmt.Sprintf("$ref:tasks-%d.jsonc", i+1),
		}
	}

	// Step 5: Write root tasks.jsonc with references
	rootPath := filepath.Join(changeDir, "tasks.jsonc")
	if err := writeRootTasksJSONC(rootPath, referenceTasks); err != nil {
		return err
	}

	// Step 6: Write each child file
	for i, group := range splitGroups {
		childPath := filepath.Join(changeDir, fmt.Sprintf("tasks-%d.jsonc", i+1))
		if err := writeChildTasksJSONC(childPath, changeID, group.parentID, group.tasks); err != nil {
			return err
		}
	}

	return nil
}

// determineSplitGroups analyzes sections and determines how to split them.
// Sections under the threshold stay together. Sections over the threshold
// are split by subsections (ID prefix grouping).
//
// Returns a slice of splitGroup representing each file to be created.
func determineSplitGroups(sections []Section) []splitGroup {
	var groups []splitGroup

	for _, section := range sections {
		if !shouldSplitSection(&section) {
			// Keep section together as one group
			groups = append(groups, splitGroup{
				parentID: section.Number,
				section:  section.Name,
				tasks:    section.Tasks,
			})
		} else {
			// Split section by subsections
			subsections := parseSubsections(section.Tasks)
			for _, subsection := range subsections {
				groups = append(groups, splitGroup{
					parentID: subsection.Prefix,
					section:  section.Name,
					tasks:    subsection.Tasks,
				})
			}
		}
	}

	return groups
}
